今日概要：
** 切片：用于表示多个数据（数据集合），可以理解为动态数组。
** 字典：键值对。例如：{"name":"曹煦阳", "age":"29", "role":"student"}
** 指针：用于表示内存地址的类型。

1 切片
切片是Go中重要的数据类型，每个切片对象内部都维护着：数组指针、切片长度、切片容量三个数据。
type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
在向切片中追加的数据个数大于容量时，内部会自动扩容且每次扩容都是当前容量的2倍（当容量超过1024时，每次扩容则只增加1/4容量）。
1.1 创建切片
	// 一、创建切片：cap为0、len为0的切片
	var nums []int

	// 二、创建切片：cap为3、len为3的切片，且指针指向[11, 22, 33]
	var data = []int{11, 22, 33}
	data := []int{11, 22, 33}

	// 三、创建切片：cap为3、len为1的切片，且指针指向默认值0
	// make只用于切片、字典、channel
	var users = make([]int, 1, 3)

	// 切片的指针类型
    var v1 = new([]int)
    // 指针类型(nil)
    var v2 *[]int

1.2 自动扩容
	// 扩容前和扩容后的内存是不同的。
	m1 := []int{11, 22, 33}
	m2 := append(m1, 44)
	fmt.Println(len(m1), cap(m1))
	fmt.Println(len(m2), cap(m2))
	m1[0] = 321
	fmt.Println(m1, m2)

1.3 常见操作（1、2、3、4、7常见功能）
1.3.1 长度和容量
    v1 := []int{11, 22, 33}
	fmt.Println(len(v1), cap(v1))
1.3.2 索引
    v1 := []string{"cxy", "Bob", "John"}
    v1[0]  v1[1]  v1[2]
    注意：索引不能大于或等于切片的长度。
1.3.3 切片
     v1 := []int{11, 22, 33, 44, 55, 66}
     v2 := v1[1:3]
     v3 := v1[1:]
     v4 := v1[:3]
     注意：通过切片切出来的数据和原切片内部存储的数据地址相同。
1.3.4 追加
     v1 := []int{11, 22, 33}
     v2 := append(v1, 44)
     v3 := append(v1, 55, 66, 77, 88)
     v4 := append(v1, []int{100, 200, 300}...)
1.3.5 删除
    s1 := []int{11, 22, 33, 44, 55, 66}
	deleteIndex := 2
	result := append(s1[:deleteIndex], s1[deleteIndex+1:]...)
	fmt.Println(result) 	//[11 22 44 55 66]
	fmt.Println(s1)			//[11 22 44 55 66 66]
	注意：使用切片时，一般不太会使用删除。效率低，修改了原切片的内容（被覆盖）。【建议使用链表】
1.3.6 插入
	r1 := []int{11, 22, 33, 44, 55, 66}
	insertIndex := 3 		//在索引3的位置插入99
	insertResult := make([]int, 0, len(r1)+1)
	insertResult = append(insertResult, r1[:insertIndex]...)
	insertResult = append(insertResult, 99)
	insertResult = append(insertResult, r1[insertIndex:]...)
	fmt.Println(r1, insertResult)
	注意：效率低下。【建议使用链表】
1.3.7 循环
    // 切片两种循环方式
    q1 := []int{11, 22, 33, 44, 55, 66}
	for i:=0; i < len(q1); i++ {
		fmt.Println(i, q1[i])
	}
	for index, value := range q1 {
		fmt.Println(index, value)
	}

1.4 切片嵌套
    ss1 := []int{11, 22, 33, 44, 55, 66}
    ss2 := [][]int{[]int{11, 22}, []int{44, 55}}

1.5 变量赋值
1.5.1 整型
	v1 := 1
	v2 := v1
	fmt.Printf("v1的内存地址：%p \n", &v1)	//0xc0000180a8
	fmt.Printf("v2的内存地址：%p \n", &v2)	//0xc0000180c0
1.5.2 布尔类型
	b1 := false
	b2 := b1
	fmt.Printf("b1的内存地址：%p \n", &b1)	//0xc0000180c8
	fmt.Printf("b2的内存地址：%p \n", &b2)	//0xc0000180c9
1.5.3 浮点型
	f1 := 3.14
	f2 := f1
	fmt.Printf("f1的内存地址：%p \n", &f1)	//0xc0000180e0
	fmt.Printf("f2的内存地址：%p \n", &f2)	//0xc0000180e8
1.5.4 字符串
	s1 := "曹煦阳"
	s2 := s1
	fmt.Printf("s1的内存地址：%p \n", &s1)	//0xc000042240
	fmt.Printf("s2的内存地址：%p \n", &s2)	//0xc000042250
	注意：字符串内部元素是不可以修改的。
1.5.5 数组
	arr1 := [2]int{6, 9}
	arr2 := arr1
	fmt.Printf("arr1的内存地址：%p \n", &arr1)	//0xc0000180f0
	fmt.Printf("arr2的内存地址：%p \n", &arr2)	//0xc000018100
	arr1[0] = 1111
	fmt.Println(arr1, arr2)
1.5.6 切片***
	sli1 := []int{6, 9}
	sli2 := sli1
	fmt.Printf("sli1的内存地址：%p \n", &sli1)	//0xc000004078
	fmt.Printf("sli2的内存地址：%p \n", &sli2)	//0xc000004090
	sli1[0] = 1111
	sli1 = append(sli1, 999)
	fmt.Println(sli1, sli2)
	注意：如果扩容，那么内部存储数据的数组就会重新开辟区域。
	总结：目前所学的所有数据类型中，在修改切片的内部元素时，会造成所有的赋值的变量同时改变（不扩容的情况下）。
	扩展：引用类型和值类型。